
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Mlab 3D to 2D example &#8212; mayavi 4.7.2 documentation</title>
    <link rel="stylesheet" href="../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Magnetic field example" href="example_magnetic_field.html" />
    <link rel="prev" title="Delaunay graph example" href="example_delaunay_graph.html" />
<style type="text/css">
  body {
    /* Very bottom copyright, etc. info */
    background: #4d598d;
  }

  .documentwrapper {
    /* Blank area on left bar */
    background: #24326e;
  }

  .related {
    /* Long horizontal nav bars */
    background: #3c4b8a!important;
  }

  .sphinxsidebarwrapper {
    /* Filled part of left sidebar */
    background: #24326e;
  }

  a {
    color: #253370;
  }

  .sphinxsidebarwrapper a {
    color: #f2f2f2!important;
  }
</style>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="example_magnetic_field.html" title="Magnetic field example"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="example_delaunay_graph.html" title="Delaunay graph example"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">mayavi 4.7.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="examples.html" accesskey="U">Example gallery</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="mlab-3d-to-2d-example">
<span id="example-mlab-3d-to-2d"></span><h1>Mlab 3D to 2D example<a class="headerlink" href="#mlab-3d-to-2d-example" title="Permalink to this headline">¶</a></h1>
<p>A script to calculate the projection of 3D world coordinates to
2D display coordinates (pixel coordinates) for a given scene.</p>
<p>The 2D pixel locations of objects in the image plane are related to their
3D world coordinates by a series of linear transformations. The specific
transformations fall under the group known as projective transformations.
This set includes pure projectivities, affine transformations,
perspective transformations, and euclidean transformations. In the case
of mlab (and most other computer visualization software), we deal with
only the perspective and euclidean cases. An overview of Projective space
can be found here: <a class="reference external" href="http://en.wikipedia.org/wiki/Projective_space">http://en.wikipedia.org/wiki/Projective_space</a> and a
thorough treatment of projective geometry can be had in the book
“Multiple View Geometry in Computer Vision” by Richard Hartley.</p>
<p>The essential thing to know for this example is that points in 3-space
are related to points in 2-space through a series of multiplications of
4x4 matrices which are the perspective and euclidean transformations. The
4x4 matrices predicate the use of length 4 vectors to represent points.
This representation is known as homogeneous coordinates, and while they
appear foriegn at first, they truly simplify all the mathematics
involved. In short, homogeneous coordinates are your friend, and you
should read about them here:
<a class="reference external" href="http://en.wikipedia.org/wiki/Homogeneous_coordinates">http://en.wikipedia.org/wiki/Homogeneous_coordinates</a></p>
<p>In the normal pinhole camera model (the ideal real world model), 3D world
points are related to 2D image points by the matrix termed the
‘essential’ matrix which is a combination of a perspective transformation
and a euclidean transformation. The perspective transformation is defined
by the camera intrinsics (focal length, imaging sensor offset, etc…)
and the euclidean transformation is defined by the cameras position and
orientation. In computer graphics, things are not so simple. This is
because computer graphics have the benefit of being able to do things
which are not possible in the real world: adding clipping planes, offset
projection centers, arbitrary distortions, etc… Thus, a slightly
different model is used.</p>
<p>What follows is the camera/view model for OpenGL and thus, VTK. I can not
guarantee that other packages follow this model.</p>
<p>There are 4 different transformations that are applied 3D world
coordinates to map them to 2D pixel coordinates. They are: the model
transform, the view transform, the perspective transform, and the
viewport or display transform.</p>
<p>In OpenGL the first two transformations are concatenated to yield the
modelview transform (called simply the view transform in VTK). The
modelview transformation applies arbitrary scaling and distortions to the
model (if they are specified) and transforms them so that the orientation
is the equivalent of looking down the negative Z axis. Imagine its as if
you relocate your camera to look down the negative Z axis, and then move
everything in the world so that you see it now as you did before you
moved the camera. The resulting coordinates are termed “eye” coordinates
in OpenGL (I don’t know that they have a name in VTK).</p>
<p>The perspective transformation applies the camera perspective to the eye
coordinates. This transform is what makes objects in the foreground look
bigger than equivalent objects in the background. In the pinhole camera
model, this transform is determined uniquely by the focal length of the
camera and its position in 3-space. In Vtk/OpenGL it is determined by the
frustum. A frustum is simply a pyramid with the top lopped off. The top
of the pyramid (a point) is the camera location, the base of the pyramid
is a plane (the far clipping plane) defined as normal to principle camera
ray at distance termed the far clipping distance, the top of the frustum
(where it’s lopped off) is the near clipping plane, with a definition
similar to that of the far clipping plane. The sides of the frustum are
determined by the aspect ratio of the camera (width/height) and its
field-of-view. Any points not lying within the frustum are not mapped to
the screen (as they would lie outside the viewable area). The
perspective transformation has the effect of scaling everything within
the frustum to fit within a cube defined in the range (-1,1)(-1,1)(-1,1)
as represented by homogeneous coordinates. The last phrase there is
important, the first 3 coordinates will not, in general, be within the
unity range until we divide through by the last coordinate (See the
wikipedia on homogeneous coordinates if this is confusing). The resulting
coordinates are termed (appropriately enough) normalized view
coordinates.</p>
<p>The last transformation (the viewport transformation) takes us from
normalized view coordinates to display coordinates. At this point, you
may be asking yourself ‘why not just go directly to display coordinates,
why need normalized view coordinates at all?’, the answer is that we may
want to embed more than one view in a particular window, there will
therefore be different transformations to take each view to an
appropriate position an size in the window. The normalized view
coordinates provide a nice common ground so-to-speak. At any rate, the
viewport transformation simply scales and translates the X and Y
coordinates of the normalized view coordinates to the appropriate pixel
coordinates. We don’t use the Z value in our example because we don’t
care about it. It is used for other various things however.</p>
<p>That’s all there is to it, pretty simple right? Right. Here is an overview:</p>
<dl class="docutils">
<dt>Given a set of 3D world coordinates:</dt>
<dd><ul class="first last simple">
<li>Apply the modelview transformation (view transform in VTK) to get eye
coordinates</li>
<li>Apply the perspective transformation to get normalized view coordinates</li>
<li>Apply the viewport transformation to get display coordinates</li>
</ul>
</dd>
</dl>
<p>VTK provides a nice method to retrieve a 4x4 matrix that combines the
first two operations. As far as I can tell, VTK does not export a method
to retrieve the 4x4 matrix representing the viewport transformation, so
we are on our there to create one (no worries though, its not hard, as
you will see).</p>
<p>Now that the prelimenaries are out of the way, lets get started.</p>
<p><strong>Python source code:</strong> <a class="reference download internal" download="" href="../_downloads/1f533870b9f95e947f8ef9a74cc73ce9/mlab_3D_to_2D.py"><code class="xref download docutils literal notranslate"><span class="pre">mlab_3D_to_2D.py</span></code></a></p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
<span class="s2"># Author: S. Chris Colbert &lt;sccolbert@gmail.com&gt;</span>
<span class="s2"># Copyright (c) 2009, S. Chris Colbert</span>
<span class="s2"># License: BSD Style</span>

<span class="s2">from __future__ import print_function</span>

<span class="s2"># this import is here because we need to ensure that matplotlib uses the</span>
<span class="s2"># wx backend and having regular code outside the main block is PyTaboo.</span>
<span class="s2"># It needs to be imported first, so that matplotlib can impose the</span>
<span class="s2"># version of Wx it requires.</span>
<span class="s2">import matplotlib</span>
<span class="s2">matplotlib.use(&#39;WXAgg&#39;)</span>
<span class="s2">import pylab as pl</span>


<span class="s2">import numpy as np</span>
<span class="s2">from mayavi import mlab</span>
<span class="s2">from mayavi.core.ui.mayavi_scene import MayaviScene</span>

<span class="s2">def get_world_to_view_matrix(mlab_scene):</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="n">returns</span> <span class="n">the</span> <span class="mi">4</span><span class="n">x4</span> <span class="n">matrix</span> <span class="n">that</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">concatenation</span> <span class="n">of</span> <span class="n">the</span> <span class="n">modelview</span> <span class="n">transform</span> <span class="ow">and</span>
    <span class="n">perspective</span> <span class="n">transform</span><span class="o">.</span> <span class="n">Takes</span> <span class="k">as</span> <span class="nb">input</span> <span class="n">an</span> <span class="n">mlab</span> <span class="n">scene</span> <span class="nb">object</span><span class="o">.</span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    if not isinstance(mlab_scene, MayaviScene):</span>
<span class="s2">        raise TypeError(&#39;argument must be an instance of MayaviScene&#39;)</span>


<span class="s2">    # The VTK method needs the aspect ratio and near and far clipping planes</span>
<span class="s2">    # in order to return the proper transform. So we query the current scene</span>
<span class="s2">    # object to get the parameters we need.</span>
<span class="s2">    scene_size = tuple(mlab_scene.get_size())</span>
<span class="s2">    clip_range = mlab_scene.camera.clipping_range</span>
<span class="s2">    aspect_ratio = float(scene_size[0])/float(scene_size[1])</span>

<span class="s2">    # this actually just gets a vtk matrix object, we can&#39;t really do anything with it yet</span>
<span class="s2">    vtk_comb_trans_mat = mlab_scene.camera.get_composite_projection_transform_matrix(</span>
<span class="s2">                                aspect_ratio, clip_range[0], clip_range[1])</span>

<span class="s2">     # get the vtk mat as a numpy array</span>
<span class="s2">    np_comb_trans_mat = vtk_comb_trans_mat.to_array()</span>

<span class="s2">    return np_comb_trans_mat</span>


<span class="s2">def get_view_to_display_matrix(mlab_scene):</span>
<span class="s2">    &quot;&quot;&quot;</span> <span class="n">this</span> <span class="n">function</span> <span class="n">returns</span> <span class="n">a</span> <span class="mi">4</span><span class="n">x4</span> <span class="n">matrix</span> <span class="n">that</span> <span class="n">will</span> <span class="n">convert</span> <span class="n">normalized</span>
        <span class="n">view</span> <span class="n">coordinates</span> <span class="n">to</span> <span class="n">display</span> <span class="n">coordinates</span><span class="o">.</span> <span class="n">It</span><span class="s1">&#39;s assumed that the view should</span>
        <span class="n">take</span> <span class="n">up</span> <span class="n">the</span> <span class="n">entire</span> <span class="n">window</span> <span class="ow">and</span> <span class="n">that</span> <span class="n">the</span> <span class="n">origin</span> <span class="n">of</span> <span class="n">the</span> <span class="n">window</span> <span class="ow">is</span> <span class="ow">in</span> <span class="n">the</span>
        <span class="n">upper</span> <span class="n">left</span> <span class="n">corner</span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    if not (isinstance(mlab_scene, MayaviScene)):</span>
<span class="s2">        raise TypeError(&#39;argument must be an instance of MayaviScene&#39;)</span>

<span class="s2">    # this gets the client size of the window</span>
<span class="s2">    x, y = tuple(mlab_scene.get_size())</span>

<span class="s2">    # normalized view coordinates have the origin in the middle of the space</span>
<span class="s2">    # so we need to scale by width and height of the display window and shift</span>
<span class="s2">    # by half width and half height. The matrix accomplishes that.</span>
<span class="s2">    view_to_disp_mat = np.array([[x/2.0,      0.,   0.,   x/2.0],</span>
<span class="s2">                                 [   0.,  -y/2.0,   0.,   y/2.0],</span>
<span class="s2">                                 [   0.,      0.,   1.,      0.],</span>
<span class="s2">                                 [   0.,      0.,   0.,      1.]])</span>

<span class="s2">    return view_to_disp_mat</span>


<span class="s2">def apply_transform_to_points(points, trans_mat):</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="n">a</span> <span class="n">function</span> <span class="n">that</span> <span class="n">applies</span> <span class="n">a</span> <span class="mi">4</span><span class="n">x4</span> <span class="n">transformation</span> <span class="n">matrix</span> <span class="n">to</span> <span class="n">an</span> <span class="n">of</span>
        <span class="n">homogeneous</span> <span class="n">points</span><span class="o">.</span> <span class="n">The</span> <span class="n">array</span> <span class="n">of</span> <span class="n">points</span> <span class="n">should</span> <span class="n">have</span> <span class="n">shape</span> <span class="n">Nx4</span><span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    if not trans_mat.shape == (4, 4):</span>
<span class="s2">        raise ValueError(&#39;transform matrix must be 4x4&#39;)</span>

<span class="s2">    if not points.shape[1] == 4:</span>
<span class="s2">        raise ValueError(&#39;point array must have shape Nx4&#39;)</span>

<span class="s2">    return np.dot(trans_mat, points.T).T</span>


<span class="s2">if __name__ == &#39;__main__&#39;:</span>
<span class="s2">    f = mlab.figure()</span>

<span class="s2">    N = 4</span>

<span class="s2">    # create a few points in 3-space</span>
<span class="s2">    X = np.random.random_integers(-3, 3, N)</span>
<span class="s2">    Y = np.random.random_integers(-3, 3, N)</span>
<span class="s2">    Z = np.random.random_integers(-3, 3, N)</span>

<span class="s2">    # plot the points with mlab</span>
<span class="s2">    pts = mlab.points3d(X, Y, Z)</span>

<span class="s2">    # now were going to create a single N x 4 array of our points</span>
<span class="s2">    # adding a fourth column of ones expresses the world points in</span>
<span class="s2">    # homogenous coordinates</span>
<span class="s2">    W = np.ones(X.shape)</span>
<span class="s2">    hmgns_world_coords = np.column_stack((X, Y, Z, W))</span>

<span class="s2">    # applying the first transform will give us &#39;unnormalized&#39; view</span>
<span class="s2">    # coordinates we also have to get the transform matrix for the</span>
<span class="s2">    # current scene view</span>
<span class="s2">    comb_trans_mat = get_world_to_view_matrix(f.scene)</span>
<span class="s2">    view_coords = </span><span class="se">\</span>
<span class="s2">            apply_transform_to_points(hmgns_world_coords, comb_trans_mat)</span>

<span class="s2">    # to get normalized view coordinates, we divide through by the fourth</span>
<span class="s2">    # element</span>
<span class="s2">    norm_view_coords = view_coords / (view_coords[:, 3].reshape(-1, 1))</span>

<span class="s2">    # the last step is to transform from normalized view coordinates to</span>
<span class="s2">    # display coordinates.</span>
<span class="s2">    view_to_disp_mat = get_view_to_display_matrix(f.scene)</span>
<span class="s2">    disp_coords = apply_transform_to_points(norm_view_coords, view_to_disp_mat)</span>

<span class="s2">    # at this point disp_coords is an Nx4 array of homogenous coordinates</span>
<span class="s2">    # where X and Y are the pixel coordinates of the X and Y 3D world</span>
<span class="s2">    # coordinates, so lets take a screenshot of mlab view and open it</span>
<span class="s2">    # with matplotlib so we can check the accuracy</span>
<span class="s2">    img = mlab.screenshot()</span>
<span class="s2">    pl.imshow(img)</span>

<span class="s2">    for i in range(N):</span>
<span class="s2">        print(&#39;Point </span><span class="si">%d</span><span class="s2">:  (x, y) &#39; </span><span class="si">% i</span><span class="s2">, disp_coords[:, 0:2][i])</span>
<span class="s2">        pl.plot([disp_coords[:, 0][i]], [disp_coords[:, 1][i]], &#39;ro&#39;)</span>

<span class="s2">    pl.show()</span>

<span class="s2">    # you should check that the printed coordinates correspond to the</span>
<span class="s2">    # proper points on the screen</span>

<span class="s2">    mlab.show()</span>

<span class="s2">#EOF</span>
</pre></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/mayavi-logo.png" alt="Logo"/>
            </a></p>
  <h4>Previous topic</h4>
  <p class="topless"><a href="example_delaunay_graph.html"
                        title="previous chapter">Delaunay graph example</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="example_magnetic_field.html"
                        title="next chapter">Magnetic field example</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/auto/example_mlab_3D_to_2D.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="example_magnetic_field.html" title="Magnetic field example"
             >next</a> |</li>
        <li class="right" >
          <a href="example_delaunay_graph.html" title="Delaunay graph example"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">mayavi 4.7.2 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="examples.html" >Example gallery</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2018, Enthought Inc..
      Last updated on Aug 31, 2020.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>