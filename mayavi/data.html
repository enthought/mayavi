
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Data representation in Mayavi &#8212; mayavi 4.8.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Objects populating the Mayavi pipeline" href="mayavi_objects.html" />
    <link rel="prev" title="Organisation of Mayavi visualizations: the pipeline" href="pipeline.html" />
<style type="text/css">
  body {
    /* Very bottom copyright, etc. info */
    background: #4d598d;
  }

  .documentwrapper {
    /* Blank area on left bar */
    background: #24326e;
  }

  .related {
    /* Long horizontal nav bars */
    background: #3c4b8a!important;
  }

  .sphinxsidebarwrapper {
    /* Filled part of left sidebar */
    background: #24326e;
  }

  a {
    color: #253370;
  }

  .sphinxsidebarwrapper a {
    color: #f2f2f2!important;
  }
</style>

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mayavi_objects.html" title="Objects populating the Mayavi pipeline"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pipeline.html" title="Organisation of Mayavi visualizations: the pipeline"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">mayavi 4.8.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="advanced_use.html" accesskey="U">Advanced use of Mayavi</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Data representation in Mayavi</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="data-representation-in-mayavi">
<span id="data-structures-used-by-mayavi"></span><h1>Data representation in Mayavi<a class="headerlink" href="#data-representation-in-mayavi" title="Permalink to this heading">¶</a></h1>
<p>Describing data in three dimensions in the general case is a complex
problem. Mayavi helps you focus on your visualization work and not worry
too much about the underlying data structures, for instance using mlab
(see <a class="reference internal" href="mlab.html#simple-scripting-with-mlab"><span class="std std-ref">mlab: Python scripting for 3D plotting</span></a>). We suggest you create sources
for Mayavi using <cite>mlab</cite> or Mayavi sources when possible. However, it
helps to understand the VTK data structures that Mayavi uses if you want
to create data with a specific structure for a more efficient
visualization, or if you want to extract the data from the Mayavi
pipeline.</p>
<nav class="contents local" id="outline">
<p class="topic-title">Outline</p>
<ul class="simple">
<li><p><a class="reference internal" href="#introduction-to-tvtk-datasets" id="id1">Introduction to TVTK datasets</a></p></li>
<li><p><a class="reference internal" href="#the-flow-of-data" id="id2">The flow of data</a></p></li>
<li><p><a class="reference internal" href="#retrieving-the-data-from-mayavi-pipelines" id="id3">Retrieving the data from Mayavi pipelines</a></p></li>
<li><p><a class="reference internal" href="#dissection-of-the-different-tvtk-datasets" id="id4">Dissection of the different TVTK datasets</a></p></li>
<li><p><a class="reference internal" href="#inserting-tvtk-datasets-in-the-mayavi-pipeline" id="id5">Inserting TVTK datasets in the Mayavi pipeline</a></p></li>
</ul>
</nav>
<hr class="docutils" />
<aside class="topic">
<p class="topic-title">Mayavi data sources and VTK datasets</p>
<ul class="simple">
<li><p>When you load a file, or you expose data in Mayavi using one of the
<cite>mlab.pipeline</cite> source functions (see <a class="reference internal" href="mlab_pipeline.html#mlab-data-source"><span class="std std-ref">Data sources</span></a>), you
create an object in the Mayavi pipeline that is attached to a
scene. This object is a Mayavi source, and serves to describe the
data and its properties to the Mayavi pipeline.</p></li>
<li><p>The internal structures use to represent to data in 3D all across
Mayavi are VTK datasets, as described below.</p></li>
</ul>
<p>One should not confuse VTK (or TVTK) <cite>datasets</cite> and Mayavi <cite>data
sources</cite>. There is a finite and small number of datasets. However,
many pipeline objects could be constructed to fit in the pipeline
below a scene and providing datasets to the pipeline.</p>
</aside>
<section id="introduction-to-tvtk-datasets">
<h2><a class="toc-backref" href="#id1" role="doc-backlink">Introduction to TVTK datasets</a><a class="headerlink" href="#introduction-to-tvtk-datasets" title="Permalink to this heading">¶</a></h2>
<p>Mayavi uses the VTK library for all its visualization needs, via TVTK
(Traited VTK). The data is exposed internally, by the sources, or at the
output of the filters, as VTK datasets, described below. Understanding
these structures is useful not only to manipulate them, but also to
understand what happens when using filters to transform the data in the
pipeline.</p>
<p>A dataset is defined by many different characteristics:</p>
<img alt="_images/dataset_diagram.jpg" src="_images/dataset_diagram.jpg" />
<dl class="field-list">
<dt class="field-odd">Connectivity<span class="colon">:</span></dt>
<dd class="field-odd"><p>Connectivity is not only necessary to draw lines between the
different points, it is also needed to define a volume.</p>
<p><strong>Implicit connectivity</strong>: connectivity or positioning is implicit. In
this case the data is considered as arranged on a lattice-like structure,
with equal number of layers in each direction, x increasing first along
the array, then y and finally z.</p>
</dd>
<dt class="field-even">Data<span class="colon">:</span></dt>
<dd class="field-even"><p>Dataset are made of points positioned in 3D, with the corresponding
data. Each dataset can carry several data components.</p>
<p><strong>Scalar or Vectors data</strong>: The data can be scalar, in which case VTK
can perform operations such as taking the gradient and display the
data with a colormap, or vector, in which case VTK can perform an
integration to display streamlines, display the vectors, or extract the
norm of the vectors, to create a scalar dataset.</p>
<p><strong>Cell data and point data</strong>: Each VTK dataset is defined by vertices and
cells, explicitly or implicitly. The data, scalar or vector, can be
positioned either on the vertices, in which case it is called point data,
or associated with a cell, in which case it is called cell data.
Point data is stored in the <cite>.point_data</cite> attribute of the dataset,
and the cell data is stored in the <cite>.cell_data</cite> attribute.</p>
<p>In addition the data arrays have an associated name, which is used in
Mayavi to specify on which data component module or filter apply (eg:
using the`SetActiveAttribute` filter).</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><strong>VTK array ordering</strong></p>
<p>All VTK arrays, whether it be for data or position, are exposed as (n, 3)
numpy arrays for 3D components, and flat (n, ) array for 1D components.
The index vary in the opposite order as numpy: z first, y and then x.
Thus to go from a 3D numpy array to the corresponding flatten VTK array,
the operation is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">vtk_array</span> <span class="o">=</span> <span class="n">numpy_array</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
</pre></div>
</div>
</div>
<p>An complete list of the VTK datasets used by Mayavi is given <a class="reference external" href="dissection_vtk_datasets">below</a>, after a tour of the Mayavi pipeline.</p>
</section>
<section id="the-flow-of-data">
<h2><a class="toc-backref" href="#id2" role="doc-backlink">The flow of data</a><a class="headerlink" href="#the-flow-of-data" title="Permalink to this heading">¶</a></h2>
<p>As described <a class="reference internal" href="overview.html#pipeline-model"><span class="std std-ref">earlier</span></a>, Mayavi builds visualization by
assembling pipelines, where the data is loaded in Mayavi by a <cite>data
source</cite>, and it can be transformed by <cite>filters</cite> and visualized by
<cite>modules</cite>.</p>
<p>To retrieve the data displayed by Mayavi, to modify it via Python code,
or to benefit from the data processing steps performed by the Mayavi
filters, it can be useful to “open up” the Mayavi pipeline and understand
how the data flows in it.</p>
<p>Inside the Mayavi pipeline, the 3D data flowing between sources filters
and modules is stored in VTK datasets. Each source or filter has an
<cite>outputs</cite> attribute, which is a list of VTK <cite>datasets</cite> describing the
data output by the object.</p>
<dl>
<dt>For example:</dt><dd><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">mayavi</span> <span class="kn">import</span> <span class="n">mlab</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iso</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">contour3d</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>The parent of <cite>iso</cite> is its ‘Colors and legend’ node, the parent of
which is the source feeding into <cite>iso</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">iso</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">outputs</span>
<span class="go">[&lt;tvtk_classes.image_data.ImageData object at 0xf08220c&gt;]</span>
</pre></div>
</div>
<p>Thus we can see that the Mayavi source created by <cite>mlab.surf</cite> exposes
an <a class="reference internal" href="#imagedata">ImageData</a> VTK dataset.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To retrieve the VTK datasets feeding in an arbitrary object, the mlab
function <a class="reference internal" href="auto/mlab_pipeline_tools.html#mayavi.tools.pipeline.get_vtk_src" title="mayavi.tools.pipeline.get_vtk_src"><code class="xref py py-func docutils literal notranslate"><span class="pre">pipeline.get_vtk_src()</span></code></a> may be useful. In the above
example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">get_vtk_src</span><span class="p">(</span><span class="n">iso</span><span class="p">)</span>
<span class="go">[&lt;tvtk_classes.image_data.ImageData object at 0xf08220c&gt;]</span>
</pre></div>
</div>
</div>
</section>
<section id="retrieving-the-data-from-mayavi-pipelines">
<span id="retrieving-data"></span><h2><a class="toc-backref" href="#id3" role="doc-backlink">Retrieving the data from Mayavi pipelines</a><a class="headerlink" href="#retrieving-the-data-from-mayavi-pipelines" title="Permalink to this heading">¶</a></h2>
<section id="probing-data-at-given-positions">
<h3>Probing data at given positions<a class="headerlink" href="#probing-data-at-given-positions" title="Permalink to this heading">¶</a></h3>
<p>If you simply want to retrieve the data values described by a Mayavi
object a given position in space, you can use the
<a class="reference internal" href="auto/mlab_pipeline_data.html#mayavi.tools.pipeline.probe_data" title="mayavi.tools.pipeline.probe_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">pipeline.probe_data()</span></code></a> function (<strong>warning</strong> the <cite>probe_data</cite>
function is new in Mayavi 3.4.0)</p>
<p>For example, if you have a set of irregularly spaced data points with no
connectivity information:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">z</span><span class="o">**</span><span class="mi">2</span>
</pre></div>
</div>
<p>You can expose them as a Mayavi source of unconnected points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">scalar_scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>and visualize these points for debugging:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pts</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">glyph</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">scale_mode</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span>
<span class="gp">... </span>                                <span class="n">scale_factor</span><span class="o">=</span><span class="mf">.1</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting data is not defined in the volume, but only at the given
position: as there is no connectivity information, Mayavi cannot
interpolate between the points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">probe_data</span><span class="p">(</span><span class="n">pts</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">)</span>
<span class="go">array([ 0. ])</span>
</pre></div>
</div>
<p>To define volumetric data, you can use a <code class="docutils literal notranslate"><span class="pre">delaunay3d</span></code> filter:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">field</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">delaunay3d</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
</pre></div>
</div>
<p>Now you can probe the value of the volumetric data anywhere. It will be
non zero in the convex hull of the points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Probe in the center of the cloud of points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">probe_data</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">)</span>
<span class="go">array([ 0.78386768])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Probe on the initial points</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_probed</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">probe_data</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">data_probed</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Probe outside the cloud</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">probe_data</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">.5</span><span class="p">)</span>
<span class="go">array([ 0.])</span>
</pre></div>
</div>
</section>
<section id="inspecting-the-internals-of-the-data-structures">
<h3>Inspecting the internals of the data structures<a class="headerlink" href="#inspecting-the-internals-of-the-data-structures" title="Permalink to this heading">¶</a></h3>
<p>You may be interested in the data carried by the TVTK datasets themselves,
rather than the values they represent, for instance to replicate them.
For this, you can retrieve the TVTK datasets, and inspect them.</p>
<section id="extracting-data-points-and-values">
<h4>Extracting data points and values<a class="headerlink" href="#extracting-data-points-and-values" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>The positions of all the points of a TVTK dataset can be accessed via its
<cite>points</cite> attribute. Retrieving the dataset from the <cite>field</cite> object of
the previous example, we can view the data points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span><span class="o">.</span><span class="n">points</span>
<span class="go">[(0.72227946564137335, 0.23729151639368518, 0.24443798107195291), ...,</span>
<span class="go">(0.13398528550831601, 0.80368395047618579, 0.31098842991116804)], length = 100</span>
</pre></div>
</div>
<p>This is a TVTK array. For us, it is more useful to convert it to a numpy
array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">points</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">points</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 3)</span>
</pre></div>
</div>
<p>To retrieve the original <cite>x</cite>, <cite>y</cite>, <cite>z</cite> positions of the data points
specified, we can transpose the array:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>The corresponding data values can be found in the <cite>point_data.scalars</cite>
attribute of the dataset, as the data is located on the points, and not
in the cells, and it is scalar data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dataset</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="mi">100</span><span class="p">,)</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="extracting-lines">
<h4>Extracting lines<a class="headerlink" href="#extracting-lines" title="Permalink to this heading">¶</a></h4>
<blockquote>
<div><p>If we want to extract the edges of the Delaunay tessellation, we can
apply the ExtractEdges filter to the <cite>field</cite> from the previous example
and inspect its output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">extract_edges</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">edges</span><span class="o">.</span><span class="n">outputs</span>
<span class="go">[&lt;tvtk_classes.poly_data.PolyData object at 0xf34e5fc&gt;]</span>
</pre></div>
</div>
<p>We can see that the output is a <a class="reference internal" href="#polydata">PolyData</a> dataset. Looking at how these
are build (see <a class="reference internal" href="#polydata">PolyData</a>), we see that the connectivity information is
help in the <cite>lines</cite> attribute (that we convert to a numpy array using its
<cite>.to_array()</cite> method):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">outputs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pd</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">to_array</span><span class="p">()</span>
<span class="go">array([ 2,  0,  1, ...,  2, 97, 18])</span>
</pre></div>
</div>
<p>The way this array is build is a sequence of a length descriptor,
followed by the indices of the data points connected together in the
points array retrieved earlier. Here we have only sets of pairs of points
connected together: the array is an alternation of <cite>2</cite> followed by a pair
of indices.</p>
<p>A full example illustrating how to use the VTK Delaunay filter to extract
a graph is given in <a class="reference internal" href="auto/example_delaunay_graph.html#example-delaunay-graph"><span class="std std-ref">Delaunay graph example</span></a>.</p>
</div></blockquote>
</section>
</section>
<section id="headless-use-of-mayavi-for-the-algorithms-without-visualization">
<h3>Headless use of Mayavi for the algorithms, without visualization<a class="headerlink" href="#headless-use-of-mayavi-for-the-algorithms-without-visualization" title="Permalink to this heading">¶</a></h3>
<p>As you can see from the above example, it can be interesting to use
Mayavi just for the numerical algorithm operating on 3D data, as the
Delaunay tessellation and interpolation demoed.</p>
<p>To run such examples headless, simply create the source with the
keyword argument <cite>figure=False</cite>. As a result the sources will not be
attached to any engine, but you will still be able to use filters, and to
probe the data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">src</span> <span class="o">=</span> <span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">scalar_scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">figure</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="dissection-of-the-different-tvtk-datasets">
<span id="dissection-vtk-datasets"></span><h2><a class="toc-backref" href="#id4" role="doc-backlink">Dissection of the different TVTK datasets</a><a class="headerlink" href="#dissection-of-the-different-tvtk-datasets" title="Permalink to this heading">¶</a></h2>
<p>The 5 TVTK structures used are the following (ordered by the cost of
visualizing them).:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>VTK name</p></th>
<th class="head"><p>Connectivity</p></th>
<th class="head"><p>Suitable for</p></th>
<th class="head"><p>Required information</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="#imagedata">ImageData</a></p></td>
<td><p>Implicit</p></td>
<td><p>Volumes and surfaces</p></td>
<td><p>3D data array and spacing along each axis</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#rectilineargrid">RectilinearGrid</a></p></td>
<td><p>Implicit</p></td>
<td><p>Volumes and surfaces</p></td>
<td><p>3D data array and 1D array of spacing for each axis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#structuredgrid">StructuredGrid</a></p></td>
<td><p>Implicit</p></td>
<td><p>Volumes and surfaces</p></td>
<td><p>3D data array and 3D position arrays for each axis</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#polydata">PolyData</a></p></td>
<td><p>Explicit</p></td>
<td><p>Points, lines and surfaces</p></td>
<td><p>x, y, z, positions of vertices and arrays of surface Cells</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#unstructuredgrid">UnstructuredGrid</a></p></td>
<td><p>Explicit</p></td>
<td><p>Volumes and surfaces</p></td>
<td><p>x, y, z positions of vertices and arrays of volume Cells</p></td>
</tr>
</tbody>
</table>
<section id="imagedata">
<span id="image-data"></span><h3>ImageData<a class="headerlink" href="#imagedata" title="Permalink to this heading">¶</a></h3>
<p>This dataset is made of data points positioned on an orthogonal grid,
with constant spacing along each axis. The position of the data points
are inferred from their position on the data array (implicit
positioning), an origin and a spacing between 2 slices along each axis.
In 2D, this can be understood as a raster image. This is the data
structure created by the <cite>ArraySource</cite> mayavi source, from a 3D numpy
array, as well as the <cite>mlab.pipeline.scalar_field</cite> and
<cite>mlab.pipeline.vector_field</cite> factory functions, if the <cite>x</cite>, <cite>y</cite> and
<cite>z</cite> arrays are not explicitly specified.</p>
<img alt="_images/image_data.jpg" src="_images/image_data.jpg" />
<p>Creating a <cite>tvtk.ImageData</cite> object from numpy arrays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tvtk.api</span> <span class="kn">import</span> <span class="n">tvtk</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">random</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">ImageData</span><span class="p">(</span><span class="n">spacing</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">i</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="n">i</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;scalars&#39;</span>
<span class="n">i</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</section>
<section id="rectilineargrid">
<h3>RectilinearGrid<a class="headerlink" href="#rectilineargrid" title="Permalink to this heading">¶</a></h3>
<p>This dataset is made of data points positioned on an orthogonal grid,
with arbitrary spacing along the various axis. The position of the data
points are inferred from their position on the data array, an
origin and the list of spacings of each axis.</p>
<img alt="_images/rectilinear_grid.jpg" src="_images/rectilinear_grid.jpg" />
<p>Creating a <cite>tvtk.RectilinearGrid</cite> object from numpy arrays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tvtk.api</span> <span class="kn">import</span> <span class="n">tvtk</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">random</span><span class="p">,</span> <span class="n">array</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">RectilinearGrid</span><span class="p">()</span>
<span class="n">r</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="n">r</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;scalars&#39;</span>
<span class="n">r</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
<span class="n">r</span><span class="o">.</span><span class="n">x_coordinates</span> <span class="o">=</span> <span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">))</span>
<span class="n">r</span><span class="o">.</span><span class="n">y_coordinates</span> <span class="o">=</span> <span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="n">r</span><span class="o">.</span><span class="n">z_coordinates</span> <span class="o">=</span> <span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="structuredgrid">
<h3>StructuredGrid<a class="headerlink" href="#structuredgrid" title="Permalink to this heading">¶</a></h3>
<p>This dataset is made of data points positioned on arbitrary grid: each
point is connected to its nearest neighbors on the data array. The
position of the data points are fully described by 1 coordinate
arrays, specifying x, y and z for each point.</p>
<img alt="_images/structured_grid.jpg" src="_images/structured_grid.jpg" />
<p>Creating a <cite>tvtk.StructuredGrid</cite> object from numpy arrays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">linspace</span><span class="p">,</span> <span class="n">random</span>
<span class="kn">from</span> <span class="nn">tvtk.api</span> <span class="kn">import</span> <span class="n">tvtk</span>

<span class="k">def</span> <span class="nf">generate_annulus</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Generate points for structured grid for a cylindrical annular</span>
<span class="sd">        volume.  This method is useful for generating a unstructured</span>
<span class="sd">        cylindrical mesh for VTK.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find the x values and y values for each plane.</span>
    <span class="n">x_plane</span> <span class="o">=</span> <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">r</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">y_plane</span> <span class="o">=</span> <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">r</span><span class="p">[:,</span><span class="kc">None</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

    <span class="c1"># Allocate an array for all the points.  We&#39;ll have len(x_plane)</span>
    <span class="c1"># points on each plane, and we have a plane for each z value, so</span>
    <span class="c1"># we need len(x_plane)*len(z) points.</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x_plane</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="mi">3</span><span class="p">])</span>

    <span class="c1"># Loop through the points for each plane and fill them with the</span>
    <span class="c1"># correct x,y,z values.</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">z_plane</span> <span class="ow">in</span> <span class="n">z</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">x_plane</span><span class="p">)</span>
        <span class="c1"># slice out a plane of the output points and fill it</span>
        <span class="c1"># with the x,y, and z values for this plane.  The x,y</span>
        <span class="c1"># values are the same for every plane.  The z value</span>
        <span class="c1"># is set to the current z</span>
        <span class="n">plane_points</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="n">plane_points</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_plane</span>
        <span class="n">plane_points</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">y_plane</span>
        <span class="n">plane_points</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z_plane</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">end</span>

    <span class="k">return</span> <span class="n">points</span>

<span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">theta</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">pi</span><span class="p">,</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">pts</span> <span class="o">=</span> <span class="n">generate_annulus</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
<span class="n">sgrid</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">StructuredGrid</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="p">(</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="n">sgrid</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">pts</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dims</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
<span class="n">sgrid</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="n">ravel</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
<span class="n">sgrid</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;scalars&#39;</span>
</pre></div>
</div>
</section>
<section id="polydata">
<span id="poly-data"></span><h3>PolyData<a class="headerlink" href="#polydata" title="Permalink to this heading">¶</a></h3>
<p>This dataset is made of arbitrarily positioned data points that can
be connected to form lines, or grouped in polygons to from surfaces
(the polygons are broken up in triangles). Unlike the other datasets,
this one cannot be used to describe volumetric data. The is the dataset
created by the <cite>mlab.pipeline.scalar_scatter</cite> and
<cite>mlab.pipeline.vector_scatter</cite> functions.</p>
<img alt="_images/poly_data.jpg" src="_images/poly_data.jpg" />
<p>Creating a <cite>tvtk.PolyData</cite> object from numpy arrays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">random</span>
<span class="kn">from</span> <span class="nn">tvtk.api</span> <span class="kn">import</span> <span class="n">tvtk</span>

<span class="c1"># The numpy array data.</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.5</span><span class="p">],</span>
                <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mf">1.5</span><span class="p">,</span><span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span><span class="mi">0</span><span class="p">]],</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="n">triangles</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>
                   <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span>
                    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">]])</span>
<span class="n">scalars</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="c1"># The TVTK dataset.</span>
<span class="n">mesh</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">,</span> <span class="n">polys</span><span class="o">=</span><span class="n">triangles</span><span class="p">)</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="n">scalars</span>
<span class="n">mesh</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;scalars&#39;</span>
</pre></div>
</div>
</section>
<section id="unstructuredgrid">
<h3>UnstructuredGrid<a class="headerlink" href="#unstructuredgrid" title="Permalink to this heading">¶</a></h3>
<p>This dataset is the most general dataset of all. It is made of data
points positioned arbitrarily. The connectivity between data points
can be arbitrary (any number of neighbors). It is described by
specifying connectivity, defining volumetric cells made of adjacent
data points.</p>
<img alt="_images/unstructured_grid.jpg" src="_images/unstructured_grid.jpg" />
<p>Creating a <cite>tvtk.UnstructuredGrid</cite> object from numpy arrays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span><span class="p">,</span> <span class="n">random</span>
<span class="kn">from</span> <span class="nn">tvtk.api</span> <span class="kn">import</span> <span class="n">tvtk</span>

<span class="n">points</span> <span class="o">=</span> <span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mf">1.2</span><span class="p">,</span><span class="mf">0.6</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="c1"># tetra</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span><span class="o">-</span><span class="mf">0.2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mf">1.6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mf">1.5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="c1"># Hex</span>
                <span class="p">],</span> <span class="s1">&#39;f&#39;</span><span class="p">)</span>
<span class="c1"># The cells</span>
<span class="n">cells</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="c1"># tetra</span>
               <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span> <span class="c1"># hex</span>
               <span class="p">])</span>
<span class="c1"># The offsets for the cells, i.e. the indices where the cells</span>
<span class="c1"># start.</span>
<span class="n">offset</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="n">tetra_type</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">Tetra</span><span class="p">()</span><span class="o">.</span><span class="n">cell_type</span> <span class="c1"># VTK_TETRA == 10</span>
<span class="n">hex_type</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">Hexahedron</span><span class="p">()</span><span class="o">.</span><span class="n">cell_type</span> <span class="c1"># VTK_HEXAHEDRON == 12</span>
<span class="n">cell_types</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="n">tetra_type</span><span class="p">,</span> <span class="n">hex_type</span><span class="p">])</span>
<span class="c1"># Create the array of cells unambiguously.</span>
<span class="n">cell_array</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">CellArray</span><span class="p">()</span>
<span class="n">cell_array</span><span class="o">.</span><span class="n">set_cells</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">cells</span><span class="p">)</span>
<span class="c1"># Now create the UG.</span>
<span class="n">ug</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">UnstructuredGrid</span><span class="p">(</span><span class="n">points</span><span class="o">=</span><span class="n">points</span><span class="p">)</span>
<span class="c1"># Now just set the cell types and reuse the ug locations and cells.</span>
<span class="n">ug</span><span class="o">.</span><span class="n">set_cells</span><span class="p">(</span><span class="n">cell_types</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">cell_array</span><span class="p">)</span>
<span class="n">scalars</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">(</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">ug</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="n">scalars</span>
<span class="n">ug</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;scalars&#39;</span>
</pre></div>
</div>
<aside class="topic">
<p class="topic-title">Modifying the data</p>
<p>If you want to modify the data of any of these low-level data
structures, you need to reassign data to the corresponding arrays, but
also reassign them a name. Once this is done, you should call the
‘modified()’ method of the object, to tell the pipeline that the data
has been modified:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ug</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="n">new_scalars</span>
<span class="n">ug</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;scalars&#39;</span>
<span class="n">ug</span><span class="o">.</span><span class="n">modified</span><span class="p">()</span>
</pre></div>
</div>
</aside>
</section>
<section id="external-references">
<h3>External references<a class="headerlink" href="#external-references" title="Permalink to this heading">¶</a></h3>
<p>This section of the user guide will be improved later.  For now, the
following two presentations best describe how one can create data
objects or data files for Mayavi and TVTK.</p>
<blockquote>
<div><ul>
<li><p>Presentation on TVTK and Mayavi2 for course at IIT Bombay</p>
<p><a class="reference external" href="https://github.com/enthought/mayavi/raw/master/docs/pdf/tvtk_mayavi2.pdf">https://github.com/enthought/mayavi/raw/master/docs/pdf/tvtk_mayavi2.pdf</a></p>
<p>This presentation provides information on graphics in general, 3D
data representation, creating VTK data files, creating datasets
from numpy in Python, and also about mayavi.</p>
</li>
<li><p>Presentation on making TVTK datasets using numpy arrays made for SciPy07.</p>
<p>Prabhu Ramachandran. “TVTK and MayaVi2”, SciPy’07:
Python for Scientific Computing, CalTech, Pasadena, CA, 16–17 August, 2007.</p>
<p>This presentation focuses on creating TVTK datasets using numpy
arrays.</p>
</li>
</ul>
</div></blockquote>
</section>
<section id="datasets-creation-examples">
<h3>Datasets creation examples<a class="headerlink" href="#datasets-creation-examples" title="Permalink to this heading">¶</a></h3>
<p>There are several examples in the mayavi sources that highlight the
creation of the most important datasets from numpy arrays. Specifically
they are:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="auto/example_datasets.html#example-datasets"><span class="std std-ref">Datasets example</span></a>: Generate a simple example for each type of
VTK dataset.</p></li>
<li><p><a class="reference internal" href="auto/example_polydata.html#example-polydata"><span class="std std-ref">Polydata example</span></a>:  Demonstrates how to create Polydata datasets
from numpy arrays and visualize them in mayavi.</p></li>
<li><p><a class="reference internal" href="auto/example_structured_points2d.html#example-structured-points2d"><span class="std std-ref">Structured points2d example</span></a>: Demonstrates how to create a 2D
structured points (an ImageData) dataset from numpy arrays and
visualize them in mayavi.  This is basically a square of
equispaced points.</p></li>
<li><p><a class="reference internal" href="auto/example_structured_points3d.html#example-structured-points3d"><span class="std std-ref">Structured points3d example</span></a>: Demonstrates how to create a 3D
structured points (an ImageData) dataset from numpy arrays and
visualize them in Mayavi.  This is a cube of points that are
regularly spaced.</p></li>
<li><p><a class="reference internal" href="auto/example_structured_grid.html#example-structured-grid"><span class="std std-ref">Structured grid example</span></a>: Demonstrates the creation and
visualization of a 3D structured grid.</p></li>
<li><p><a class="reference internal" href="auto/example_unstructured_grid.html#example-unstructured-grid"><span class="std std-ref">Unstructured grid example</span></a>: Demonstrates the creation and
visualization of an unstructured grid.</p></li>
</ul>
</div></blockquote>
<p>These scripts may be run like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mayavi2 -x structured_grid.py
</pre></div>
</div>
<p>or better yet, all in one go like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ mayavi2 -x polydata.py -x structured_points2d.py \
&gt; -x structured_points3d.py -x structured_grid.py -x unstructured_grid.py
</pre></div>
</div>
</section>
</section>
<section id="inserting-tvtk-datasets-in-the-mayavi-pipeline">
<h2><a class="toc-backref" href="#id5" role="doc-backlink">Inserting TVTK datasets in the Mayavi pipeline</a><a class="headerlink" href="#inserting-tvtk-datasets-in-the-mayavi-pipeline" title="Permalink to this heading">¶</a></h2>
<p>TVTK datasets can be created using directly TVTK, as illustrated in the
examples above. A VTK data source can be inserted in the Mayavi pipeline
using the VTKDataSource. For instance we can create an <cite>ImageData</cite>
dataset:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">tvtk.api</span> <span class="kn">import</span> <span class="n">tvtk</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
<span class="n">i</span> <span class="o">=</span> <span class="n">tvtk</span><span class="o">.</span><span class="n">ImageData</span><span class="p">(</span><span class="n">spacing</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="n">i</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
<span class="n">i</span><span class="o">.</span><span class="n">point_data</span><span class="o">.</span><span class="n">scalars</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;scalars&#39;</span>
<span class="n">i</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
<ul>
<li><p>If you are scripting using <a class="reference internal" href="mlab.html#simple-scripting-with-mlab"><span class="std std-ref">mlab</span></a>, the
simplest way to visualize your data is to use the <a class="reference internal" href="mlab_pipeline.html#controlling-the-pipeline-with-mlab-scripts"><span class="std std-ref">mlab.pipeline</span></a> to apply filters and
modules to your data. Indeed these functions creating filters and
modules accept VTK datasets and automatically insert them on the
pipeline. A surface module could have been used to visualize the
<cite>ImageData</cite> dataset created above as such:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">enthgouth.mayavi</span> <span class="kn">import</span> <span class="n">mlab</span>
<span class="n">mlab</span><span class="o">.</span><span class="n">pipeline</span><span class="o">.</span><span class="n">surface</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>In addition, inserting this dataset on the Mayavi pipeline with direct
control on the <cite>Engine</cite> is done as suchwith <cite>VTKDataSource</cite>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">mayavi.sources.api</span> <span class="kn">import</span> <span class="n">VTKDataSource</span>
<span class="n">src</span> <span class="o">=</span> <span class="n">VTKDataSource</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">i</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">mayavi.api</span> <span class="kn">import</span> <span class="n">Engine</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">Engine</span><span class="p">()</span>
<span class="n">e</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">new_scene</span><span class="p">()</span>
<span class="n">e</span><span class="o">.</span><span class="n">add_source</span><span class="p">(</span><span class="n">src</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
<p>Of course, unless you want specific control on the attributes of the VTK
dataset, or you are using Mayavi in the context of existing code
manipulating TVTK objects, creating an <cite>ImageData</cite> TVTK object is not
advised. The <cite>ArraySource</cite> object of Mayavi will actually create an
<cite>ImageData</cite>, but make sure you don’t get the shape wrong, which can lead
to a segmentation fault. An even easier way to create a data source for
an <cite>ImageData</cite> is to use the <cite>mlab.pipeline.scalar_field</cite> function, as
explained in the <a class="reference internal" href="mlab_pipeline.html#mlab-data-source"><span class="std std-ref">section on creating
data sources with mlab</span></a>.</p>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/mayavi-logo.png" alt="Logo"/>
            </a></p>
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#">Data representation in Mayavi</a><ul>
<li><a class="reference internal" href="#introduction-to-tvtk-datasets">Introduction to TVTK datasets</a></li>
<li><a class="reference internal" href="#the-flow-of-data">The flow of data</a></li>
<li><a class="reference internal" href="#retrieving-the-data-from-mayavi-pipelines">Retrieving the data from Mayavi pipelines</a><ul>
<li><a class="reference internal" href="#probing-data-at-given-positions">Probing data at given positions</a></li>
<li><a class="reference internal" href="#inspecting-the-internals-of-the-data-structures">Inspecting the internals of the data structures</a><ul>
<li><a class="reference internal" href="#extracting-data-points-and-values">Extracting data points and values</a></li>
<li><a class="reference internal" href="#extracting-lines">Extracting lines</a></li>
</ul>
</li>
<li><a class="reference internal" href="#headless-use-of-mayavi-for-the-algorithms-without-visualization">Headless use of Mayavi for the algorithms, without visualization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dissection-of-the-different-tvtk-datasets">Dissection of the different TVTK datasets</a><ul>
<li><a class="reference internal" href="#imagedata">ImageData</a></li>
<li><a class="reference internal" href="#rectilineargrid">RectilinearGrid</a></li>
<li><a class="reference internal" href="#structuredgrid">StructuredGrid</a></li>
<li><a class="reference internal" href="#polydata">PolyData</a></li>
<li><a class="reference internal" href="#unstructuredgrid">UnstructuredGrid</a></li>
<li><a class="reference internal" href="#external-references">External references</a></li>
<li><a class="reference internal" href="#datasets-creation-examples">Datasets creation examples</a></li>
</ul>
</li>
<li><a class="reference internal" href="#inserting-tvtk-datasets-in-the-mayavi-pipeline">Inserting TVTK datasets in the Mayavi pipeline</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="pipeline.html"
                          title="previous chapter">Organisation of Mayavi visualizations: the pipeline</a></p>
  </div>
  <div>
    <h4>Next topic</h4>
    <p class="topless"><a href="mayavi_objects.html"
                          title="next chapter">Objects populating the Mayavi pipeline</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/data.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="mayavi_objects.html" title="Objects populating the Mayavi pipeline"
             >next</a> |</li>
        <li class="right" >
          <a href="pipeline.html" title="Organisation of Mayavi visualizations: the pipeline"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">mayavi 4.8.1 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="advanced_use.html" >Advanced use of Mayavi</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Data representation in Mayavi</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2008-2018, Enthought Inc..
      Last updated on Oct 18, 2022.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.3.0.
    </div>
  </body>
</html>